<!--This document was written by Sophia and shared over Discord before being added
to the repository by Alistair. It describes the initial ideas for the protocol before they were refined-->
## PLAN FOR STRUCTURE
- The job of client-side main() is just to initialise the GUI as new TradingAppGUI(new TradingAppData(new NetworkDataSource())). All further interactions will be done through the GUI
- The above referenced classes are all client side. NetworkDataSource is the class which will communicate with the server program using the protocol system outlined later; TradingAppData provides an additional layer of abstraction and specificity such that its methods can be called by GUI interactive elements (idea borrowed from AddressBookData class). 
- "Server could not be reached" errors should be handled such that the GUI can display them
- In the server side package, a class with a basic GUI will be the class with a main(). This class will be basically the same as the week 8 exercise's NetworkServerGUI class, but also handle the trade resolutions every 5 minutes. As such, some useful info about this process (how long until the next run, info about the last run, etc) or at least a button that prints it to the console, should be present on the server GUI for debug purposes
- The NetworkServer class, an instance of which will be initialised at the start of server main() like in the address book exercise, will be built around a JDBC connection class based off the week 7 exercise (though depending on how things go we might start out with it just storing the data in a bunch of non-static map collection variables that don't persist when the server is terminated). The network connection is the most important part, and we should build the program such that nothing on the client side will need to be refactored when the database is added
- This encapsulation means that the client program will be able to treat the server connection as a black box

## COMMUNICATION PROTOCOL IDEA
I reckon the protocol should work like this unless any of you have any suggestions. Basically, the NetworkDataSource class uses its ObjectOutputStream to send each of these as separate packets: a predetermined codeword string (the value of a final variable, like the RECEIVE and STORE codewords in the week 8 exercise), a table name packet, then one or two more packets whose significance depends on the codeword. After the NetworkServer receives this through a handleConnection method very much like the one in the week 8 exercise, it will send back the query results (or a short feedback thing for non-SELECT operations) for NetworkDataSource to receive through an ObjectInputStream. Each of the below points will be a private helper method of the class. There will be one public method for every valid operation that the TradingAppData class will need to be able to call in its own (even more specific) public methods; I've given example possibilities of public methods that might call each helper

- Codeword SELECT. Further packets (helper params): 1) table name, 2) sql string of an arbitrary WHERE clause (which will have been constructed by the method calling this helper out of parameters and string literals). Server sends back a HashMap<keytype, object> (keytype may be int or string; we'll have to do some special-casing for Inventories because of its composite key). This codeword's direct helper may be called by public methods such as getOutstandingBuyOffers(String assetname) and getInventoryQuantity(String orgUnit, int assetID) and getAssetList(), which would require the use of filters that can't be covered by the special cases (in the former two cases, because multiple columns must be filtered; in the latter case, because the filter would be an empty string to get the entire table)
    - Special-case helper for cases where the filter is in "WHERE column_name = value" format. This helper takes the table name, column name, and string/int value (polymorphism may be required), constructs the where clause from them, and calls the general helper using that clause, then returns its result map. This may be called by public methods such as getBuyOffersByUser(String name) or getAllInventoryQuantities(String orgUnit); note that the latter would return an int-int map denoting asset ID and quantity respectively, since the orgunit half of the composite key is known by the fact we're filtering for it
    - Even specialer-case helper for filtering by primary key value, which only takes the table name and value, then plugs the table name into a method (let's call it "primaryKey(String table)") that uses a stored collection of all the primary key column names to get the column name to call the above-described helper, and returns a single object (null if key not found) since keys are unique. This helper may be called by public methods such as getOrgUnit(String name) and getSellOfferDetails(int id)

- Codeword INSERT. Further packets: 1) table name, 2) object with record details, 3) a Boolean flag encoding how to deal with duplicate keys, where false means to send back a failure message, and true means to add an "ON DUPLICATE KEY UPDATE" clause updating all non-key column values to the object's. The server attempts an INSERT query on the table with the column values specified in the object. It sends back the number of rows affected (found using the JDBC's getUpdateCount method), which will be 1 if the insert succeeded, 0 if the insert failed and the server-side method had to catch a SQLException for the duplicate key (only happens if the boolean packet was false), or 2 if the insert failed and the update executed instead (only happens if the bookean packet was true). 
    - The boolean options may be split into separate helper methods with useful names rather than having one helper with a magic boolean parameter. The False variation may be called in public methods as addUser(User u), while the True variation may be useful for public methods such as setInventoryQty(InventoryRecord i) to be able to do "update if exists, insert if not" in one step

- Codeword UPDATE. Further packets: 1) table name, 2) object with new details. The server attempts an UPDATE query on the table, updating all columns to the values specified in the object, with a WHERE clause determined by the primary key field of the object. As feedback, it sends back the number of records affected (1 in all normal cases since keys are unique and the method would only be able to be called in cases where the record exists, but interference between multiple clients may create circumstances for it to be 0 so the program should be able to handle it) in int format. This helper may be called by public methods such as updateUserAccess(User u, boolean newAccess) or updateOrgUnitCredits

- Codeword DELETE. Further packets: 1) table name, 2) sql string of an arbitrary WHERE clause. The server attempts a DELETE query on the table with the specified WHERE clause and sends back the number of records affected. This more general helper method should be implemented although almost all public-method-called cases will be covered by the special case, because we'll need to be able to clear entire tables while debugging
    - Special-case helper for deleting a specific key value. This will take the table name and key value, construct the WHERE clause with the help of primaryKey(String table), and call the general helper. This would be called in public methods such as cancelSellOrder(int id)

## REFACTORS FOR EXISTING OBJECT CLASS DESIGN
- Order class should be given sell order and buy order subclasses since they have some distinctions but some shared attributes. textbook inheritance
- We need an inventory record object class for sending inventories information